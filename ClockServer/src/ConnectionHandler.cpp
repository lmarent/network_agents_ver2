//
// ConnectionHandler.cpp
//
// Definition of the ConnectionHandler class.
//
// Copyright (c) 2014, ChoiceNet Project.
// and Contributors.
//
// Permission is hereby granted, free of charge, to any person or organization
// obtaining a copy of the software and accompanying documentation covered by
// this license (the "Software") to use, reproduce, display, distribute,
// execute, and transmit the Software, and to prepare derivative works of the
// Software, and to permit third-parties to whom the Software is furnished to
// do so, all subject to the following:
// 
// The copyright notices in the Software and this entire statement, including
// the above license grant, this restriction and the following disclaimer,
// must be included in all copies of the Software, in whole or in part, and
// all derivative works of the Software, unless such copies or derivative
// works are solely in the form of machine-executable object code generated by
// a source language processor.
// 
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
// SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
// FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
// ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
// DEALINGS IN THE SOFTWARE.
//


#include <Poco/Net/SocketReactor.h>
#include <Poco/Net/SocketAcceptor.h>
#include <Poco/Net/SocketNotification.h>
#include <Poco/Net/StreamSocket.h>
#include <Poco/Net/ServerSocket.h>
#include <Poco/NObserver.h>
#include <Poco/Exception.h>
#include <Poco/Thread.h>
#include <Poco/FIFOBuffer.h>
#include <Poco/Delegate.h>
#include <Poco/Util/ServerApplication.h>
#include <Poco/Util/Option.h>
#include <Poco/Util/OptionSet.h>
#include <Poco/Util/HelpFormatter.h>
#include <iostream>
#include <Poco/StringTokenizer.h>
#include <Poco/Types.h>
#include <Poco/NumberParser.h>
#include <Poco/NumberFormatter.h>

#include "FoundationException.h"
#include "ClockServerException.h"
#include "ConnectionHandler.h"
#include "ClockSys.h"
#include "ClockServer.h"
#include "Message.h"

namespace ChoiceNet
{
namespace Eco
{

ConnectionHandler::ConnectionHandler(Poco::Net::StreamSocket& socket, Poco::Net::SocketReactor& reactor):
_socket(socket),
_reactor(reactor),
_fifoIn(BUFFER_SIZE, true),
_fifoOut(BUFFER_SIZE, true)
{
	Poco::Util::Application& app = Poco::Util::Application::instance();
	
	app.logger().information("Connection from " + socket.peerAddress().toString());

	_reactor.addEventHandler(_socket, 
		Poco::NObserver<ConnectionHandler,Poco::Net::ReadableNotification>(*this, &ConnectionHandler::onSocketReadable)
		);
				
	_reactor.addEventHandler(_socket, 
		Poco::NObserver<ConnectionHandler, Poco::Net::ShutdownNotification>(*this, &ConnectionHandler::onSocketShutdown)
		);	

	_reactor.addEventHandler(_socket, 
		Poco::NObserver<ConnectionHandler, Poco::Net::ErrorNotification>(*this, &ConnectionHandler::onSocketError)
		);	

    std::cout << "Adding the hadler for idle notification" << std::endl;

	_reactor.addEventHandler(_socket, 
		Poco::NObserver<ConnectionHandler, Poco::Net::IdleNotification>(*this, &ConnectionHandler::onSocketIdle)
		);	


	_fifoOut.readable += Poco::delegate(this, &ConnectionHandler::onFIFOOutReadable);
	_fifoIn.writable += Poco::delegate(this, &ConnectionHandler::onFIFOInWritable);
				
}

ConnectionHandler::~ConnectionHandler()
{
	Poco::Util::Application& app = Poco::Util::Application::instance();
	try
	{
		std::cout << "Disconnecting" << _socket.peerAddress().toString();
		app.logger().information("Disconnecting " + _socket.peerAddress().toString());

		_reactor.removeEventHandler(_socket, Poco::NObserver<ConnectionHandler,
					Poco::Net::ReadableNotification>(*this, &ConnectionHandler::onSocketReadable));
		_reactor.removeEventHandler(_socket, Poco::NObserver<ConnectionHandler,
					Poco::Net::ShutdownNotification>(*this, &ConnectionHandler::onSocketShutdown));
		_reactor.removeEventHandler(_socket, Poco::NObserver<ConnectionHandler,
					Poco::Net::ErrorNotification>(*this, &ConnectionHandler::onSocketError));
		_reactor.removeEventHandler(_socket, Poco::NObserver<ConnectionHandler,
					Poco::Net::IdleNotification>(*this, &ConnectionHandler::onSocketIdle));

		_fifoOut.readable -= Poco::delegate(this, &ConnectionHandler::onFIFOOutReadable);
		_fifoIn.writable -= Poco::delegate(this, &ConnectionHandler::onFIFOInWritable);

	} catch (Poco::SystemException &e){
		throw ClockServerException( e.message());
	}catch(Poco::Exception &e){
		throw ClockServerException("ERROR IN CLOSING CONNECTION");
	}

}

void ConnectionHandler::onFIFOOutReadable(bool& b)
{
	if (b)
		_reactor.addEventHandler(_socket, Poco::NObserver<ConnectionHandler, 
				Poco::Net::WritableNotification>(*this, &ConnectionHandler::onSocketWritable));
	else
		_reactor.removeEventHandler(_socket, Poco::NObserver<ConnectionHandler, 
				Poco::Net::WritableNotification>(*this, &ConnectionHandler::onSocketWritable));
}

void ConnectionHandler::onFIFOInWritable(bool& b)
{
	if (b)
		_reactor.addEventHandler(_socket, Poco::NObserver<ConnectionHandler, 
				Poco::Net::ReadableNotification>(*this, &ConnectionHandler::onSocketReadable));
	else
		_reactor.removeEventHandler(_socket, Poco::NObserver<ConnectionHandler, 
				Poco::Net::ReadableNotification>(*this, &ConnectionHandler::onSocketReadable));
}

void ConnectionHandler::providerConnect(Poco::Net::SocketAddress socketAddress,
									   ChoiceNet::Eco::Message & message,
									   ChoiceNet::Eco::Message & messageResponse)
{
	std::string providerId = message.getParameter("Provider");
	std::cout << "Adding listener 1" << std::endl;
	Poco::Util::Application& app = Poco::Util::Application::instance();
	ClockServer &server = dynamic_cast<ClockServer&>(app);
	ClockSys *clocksys = server.getClockSubsystem();
	std::cout << "Adding listener 2" << std::endl;
	(*clocksys).insertListener(providerId, socketAddress, messageResponse);
	std::cout << "Added listener" << std::endl;
}

void ConnectionHandler::providerStartListening(Poco::Net::SocketAddress socketAddress, 
										       ChoiceNet::Eco::Message & message, 
										       ChoiceNet::Eco::Message & messageResponse)
{
	unsigned  Uport; 
	std::string port = message.getParameter("Port");
	bool v_result = Poco::NumberParser::tryParseUnsigned(port, Uport);
	std::string type = message.getParameter("Type");
	if ( Uport <= 0xFFFF)
	{
		Poco::Util::Application& app = Poco::Util::Application::instance();
		ClockServer &server = dynamic_cast<ClockServer&>(app);
		ClockSys * clocksys = server.getClockSubsystem();
		Poco::UInt16 u16Port = (Poco::UInt16) Uport;
		(*clocksys).startListening(socketAddress, u16Port, type, messageResponse);
	}
	else
	{
		throw ClockServerException("Invalid Port", 301);
	}	
	std::cout << "Connected to listener" << std::endl;
}

void ConnectionHandler::sendCurrentPeriod(Poco::Net::SocketAddress socketAddress, 
										  ChoiceNet::Eco::Message & messageRequest,
										  ChoiceNet::Eco::Message & messageResponse)
{
	Poco::Util::Application& app = Poco::Util::Application::instance();
	ClockServer &server = dynamic_cast<ClockServer&>(app);
	ClockSys * clocksys = server.getClockSubsystem();
	(*clocksys).sendCurrentPeriod(socketAddress, messageResponse);
}

void ConnectionHandler::disconnectListener(Poco::Net::SocketAddress socketAddress, 
										   ChoiceNet::Eco::Message & messageRequest,
										   ChoiceNet::Eco::Message & messageResponse)
{
	Poco::Util::Application& app = Poco::Util::Application::instance();
	ClockServer &server = dynamic_cast<ClockServer&>(app);
	ClockSys * clocksys = server.getClockSubsystem();
	(*clocksys).deleteListener( socketAddress, messageResponse );
}

void ConnectionHandler::getServices(Poco::Net::SocketAddress ipAddress,  
								    ChoiceNet::Eco::Message & messageRequest, 
								    ChoiceNet::Eco::Message & messageResponse)
{

	Poco::Util::Application& app = Poco::Util::Application::instance();
	app.logger().information("Request for Services");
	ClockServer &server = dynamic_cast<ClockServer&>(app);
	ClockSys *sys = server.getClockSubsystem();

	std::cout << "In get services" << std::endl;
	if (messageRequest.existsParameter("Service")){
		std::string serviceId = messageRequest.getParameter("Service");
		(*sys).getServices(serviceId, messageResponse);
	}
	else{	
		(*sys).getServices(messageResponse);
	}
	std::cout << "Ending get services" << std::endl;
}

void ConnectionHandler::errorProcedure(ChoiceNet::Eco::Message & messageResponse)
{
	messageResponse.setParameter("Status_Code", "300");
	messageResponse.setParameter("Status_Description", "Invalid Method");
}

void ConnectionHandler::doProcessing(Poco::Net::SocketAddress socketAddress, 
									 ChoiceNet::Eco::Message & message)
{

	Method meth = message.getMethod();
		
	// std::cout << "ChoiceNet::Eco::Message:" << ChoiceNet::Eco::Message.to_string() << std::endl;
		
	// This object will be the response for the calling application.
	ChoiceNet::Eco::Message messageResponse;
	messageResponse.setMethod(meth);
	try{
		switch (meth)
		{
		   case connect:
			  {
	 			// Verify the required paramters option provider
	 			// std::cout << "In Connect" << std::endl;
				providerConnect( socketAddress, message, messageResponse );
				break;
			  }	
		   case send_port:
			  {
				// Verify the required paramters option port
				// std::cout << "In send_port" << std::endl;
				providerStartListening( socketAddress, message, messageResponse );
				break;
			  }	
		   case get_current_period:
			  {
				// Verify the required paramters option port
				// std::cout << "In get_current_period" << std::endl;
				sendCurrentPeriod( socketAddress, message, messageResponse );
				break;
			  }	
		   case disconnect:
			  {
				// Verify the required paramters option DISCONNECT				
				// std::cout << "In disconnect" << std::endl;
				disconnectListener(socketAddress, message, messageResponse);
				break;
			  }
		   case get_services:
			  {
				// std::cout << "In Get Services" << std::endl;
				getServices(socketAddress, message, messageResponse);
				break;
		      }
			default: 
			  {
				// std::cout << "Invalid method" << std::endl;
				errorProcedure(messageResponse);
				break;
			  }
		}
	} 
	catch(FoundationException &e)
	{
		std::string codeStr;
		Poco::NumberFormatter::append(codeStr,e.code());
		messageResponse.setParameter("Status_Code", codeStr);
		messageResponse.setParameter("Status_Description", e.message());
	}
	catch(ClockServerException &e)
	{
		// Some required parameter was not given
		std::string codeStr;
		Poco::NumberFormatter::append(codeStr,e.code());
		messageResponse.setParameter("Status_Code", codeStr);
		messageResponse.setParameter("Status_Description", e.message());
	}
	
	// send the response for the calling agent.
	std::string responseStr = messageResponse.to_string();
	size_t charactersWritten = 0;	
	if ((responseStr.length() + 1) > (_fifoOut.size() + _fifoOut.used()))
	{
	   _fifoOut.resize(_fifoOut.used() + responseStr.length() + 1, true);
	}
    charactersWritten = _fifoOut.write(responseStr.c_str(), responseStr.length());
    std::cout << "Character written" << charactersWritten << std::endl;
}

void ConnectionHandler::onSocketReadable(const Poco::AutoPtr<Poco::Net::ReadableNotification>& pNf)
{
	// some socket implementations (windows) report available
	// bytes on client disconnect, so we double-check here
	
	Poco::Util::Application& app = Poco::Util::Application::instance();

	if (_socket.available())
	{
		
		int len = _socket.receiveBytes(_fifoIn.next(), _fifoIn.available() );

		_fifoIn.advance(len);
		
		ClockServer &server = dynamic_cast<ClockServer&>(app);
		ClockSys *sys = server.getClockSubsystem();
		ChoiceNet::Eco::Message message;

		if ((*sys).isAlreadyListener(_socket.peerAddress()))
		{
			(*sys).addStagedData(_socket.peerAddress(), _fifoIn, len);
			bool defined = true;
			do {
				Message message;
				defined = (*sys).getMessage(_socket.peerAddress(), message);
				if (defined == true){
					app.logger().debug("message to process:%s", message.to_string());
					doProcessing(_socket.peerAddress(), message);
				}
			} while (defined == true);
		}
		else
		{
			Message message;
			app.logger().debug("new listener:%s", (_socket.peerAddress()).toString().c_str());
			std::string received;
			(*sys).getMessage(_fifoIn, len, message);
			doProcessing(_socket.peerAddress(), message);
		}
	}	
	else
	{
		delete this;
		// std::cout << "Socket is unavailable" << std::endl;
	}

}

void ConnectionHandler::onSocketWritable(const Poco::AutoPtr<Poco::Net::WritableNotification>& pNf)
{
	
	int len = _socket.sendBytes((_fifoOut.buffer()).begin(), _fifoOut.used());
	_fifoOut.drain(len);
}

void ConnectionHandler::onSocketShutdown(const Poco::AutoPtr<Poco::Net::ShutdownNotification>& pNf)
{
	Poco::Util::Application& app = Poco::Util::Application::instance();
	app.logger().debug("Socket shutdown");
	std::cout << "Socket Error occurs" << std::endl;
	delete this;
}

void ConnectionHandler::onSocketError(const Poco::AutoPtr<Poco::Net::ErrorNotification>& pNf)
{
	Poco::Util::Application& app = Poco::Util::Application::instance();
	app.logger().debug("Socket Error occurs");
	std::cout << "Socket Error occurs" << std::endl;
}

void ConnectionHandler::onSocketIdle(const Poco::AutoPtr<Poco::Net::IdleNotification>& pNf)
{
	Poco::Util::Application& app = Poco::Util::Application::instance();
	app.logger().debug("On idle notification");
	std::cout << "On idle notification" << std::endl;
	sleep(0.00001);
}

}   /// End Eco namespace

}  /// End ChoiceNet namespace

