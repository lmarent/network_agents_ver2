//
// ConnectionHandler.cpp
//
// Definition of the ConnectionHandler class.
//
// Copyright (c) 2014, ChoiceNet Project.
// and Contributors.
//
// Permission is hereby granted, free of charge, to any person or organization
// obtaining a copy of the software and accompanying documentation covered by
// this license (the "Software") to use, reproduce, display, distribute,
// execute, and transmit the Software, and to prepare derivative works of the
// Software, and to permit third-parties to whom the Software is furnished to
// do so, all subject to the following:
//
// The copyright notices in the Software and this entire statement, including
// the above license grant, this restriction and the following disclaimer,
// must be included in all copies of the Software, in whole or in part, and
// all derivative works of the Software, unless such copies or derivative
// works are solely in the form of machine-executable object code generated by
// a source language processor.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
// SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
// FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
// ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
// DEALINGS IN THE SOFTWARE.
//


#include <Poco/Net/SocketReactor.h>
#include <Poco/Net/SocketAcceptor.h>
#include <Poco/Net/SocketNotification.h>
#include <Poco/Net/StreamSocket.h>
#include <Poco/Net/ServerSocket.h>
#include <Poco/NObserver.h>
#include <Poco/Exception.h>
#include <Poco/Thread.h>
#include <Poco/FIFOBuffer.h>
#include <Poco/Delegate.h>
#include <Poco/Util/ServerApplication.h>
#include <Poco/Util/Option.h>
#include <Poco/Util/OptionSet.h>
#include <Poco/Util/HelpFormatter.h>
#include <iostream>
#include <Poco/StringTokenizer.h>
#include <Poco/Types.h>
#include <Poco/NumberParser.h>
#include <Poco/NumberFormatter.h>
#include <Poco/LogStream.h>
#include <Poco/Net/NetException.h>



#include "FoundationException.h"
#include "ClockServerException.h"
#include "ConnectionHandler.h"
#include "ClockSys.h"
#include "ClockServer.h"
#include "Message.h"

using Poco::LogStream;

namespace ChoiceNet
{
namespace Eco
{

ConnectionHandler::ConnectionHandler(Poco::Net::StreamSocket& socket, Poco::Net::SocketReactor& reactor):
_socket(socket),
_reactor(reactor),
_fifoIn(BUFFER_SIZE, true),
_fifoOut(BUFFER_SIZE, true)
{
	Poco::Util::Application& app = Poco::Util::Application::instance();
	app.logger().information("Connection from " + socket.peerAddress().toString());

	_reactor.addEventHandler(_socket,
		Poco::NObserver<ConnectionHandler,Poco::Net::ReadableNotification>(*this, &ConnectionHandler::onSocketReadable)
		);

	_reactor.addEventHandler(_socket,
		Poco::NObserver<ConnectionHandler, Poco::Net::ShutdownNotification>(*this, &ConnectionHandler::onSocketShutdown)
		);

	_reactor.addEventHandler(_socket,
		Poco::NObserver<ConnectionHandler, Poco::Net::ErrorNotification>(*this, &ConnectionHandler::onSocketError)
		);

    std::cout << "Adding the hadler for idle notification" << std::endl;

	_reactor.addEventHandler(_socket,
		Poco::NObserver<ConnectionHandler, Poco::Net::IdleNotification>(*this, &ConnectionHandler::onSocketIdle)
		);


	_fifoOut.readable += Poco::delegate(this, &ConnectionHandler::onFIFOOutReadable);
	_fifoIn.writable += Poco::delegate(this, &ConnectionHandler::onFIFOInWritable);

}

ConnectionHandler::~ConnectionHandler()
{
	Poco::Util::Application& app = Poco::Util::Application::instance();

	try
	{
		app.logger().information("Disconnecting " + _socket.peerAddress().toString());
		ChoiceNet::Eco::Message messageResponse;

		ClockServer &server = dynamic_cast<ClockServer&>(app);
		ClockSys * clocksys = server.getClockSubsystem();
		(*clocksys).deleteListener( _socket.peerAddress(), messageResponse );
		app.logger().information("deleted the listener");
	}
	catch (Poco::Net::NetException &e){
		// peer not connected.
	}


	try
	{

		_reactor.removeEventHandler(_socket, Poco::NObserver<ConnectionHandler,
					Poco::Net::ReadableNotification>(*this, &ConnectionHandler::onSocketReadable));
		_reactor.removeEventHandler(_socket, Poco::NObserver<ConnectionHandler,
					Poco::Net::ShutdownNotification>(*this, &ConnectionHandler::onSocketShutdown));
		_reactor.removeEventHandler(_socket, Poco::NObserver<ConnectionHandler,
					Poco::Net::ErrorNotification>(*this, &ConnectionHandler::onSocketError));
		_reactor.removeEventHandler(_socket, Poco::NObserver<ConnectionHandler,
					Poco::Net::IdleNotification>(*this, &ConnectionHandler::onSocketIdle));

		_fifoOut.readable -= Poco::delegate(this, &ConnectionHandler::onFIFOOutReadable);
		_fifoIn.writable -= Poco::delegate(this, &ConnectionHandler::onFIFOInWritable);

	} catch (Poco::SystemException &e){
		std::cout << "closing the ConnectionHandler because a SystemException" << std::endl;
		throw ClockServerException( e.message());

	}catch(Poco::Exception &e){
		std::cout << "closing the ConnectionHandler because a PocoException" << e.className() << e.message() << std::endl;
		throw ClockServerException("ERROR IN CLOSING CONNECTION");
	}

}

void ConnectionHandler::onFIFOOutReadable(bool& b)
{
	if (b)
		_reactor.addEventHandler(_socket, Poco::NObserver<ConnectionHandler,
				Poco::Net::WritableNotification>(*this, &ConnectionHandler::onSocketWritable));
	else
		_reactor.removeEventHandler(_socket, Poco::NObserver<ConnectionHandler,
				Poco::Net::WritableNotification>(*this, &ConnectionHandler::onSocketWritable));
}

void ConnectionHandler::onFIFOInWritable(bool& b)
{
	if (b)
		_reactor.addEventHandler(_socket, Poco::NObserver<ConnectionHandler,
				Poco::Net::ReadableNotification>(*this, &ConnectionHandler::onSocketReadable));
	else
		_reactor.removeEventHandler(_socket, Poco::NObserver<ConnectionHandler,
				Poco::Net::ReadableNotification>(*this, &ConnectionHandler::onSocketReadable));
}

void ConnectionHandler::Connect(Poco::Net::SocketAddress socketAddress,
									   ChoiceNet::Eco::Message & message,
									   ChoiceNet::Eco::Message & messageResponse)
{

	Poco::Util::Application& app = Poco::Util::Application::instance();
	app.logger().information("start Connect");

	std::string listenerId = message.getParameter("Agent");
	ClockServer &server = dynamic_cast<ClockServer&>(app);
	ClockSys *clocksys = server.getClockSubsystem();
	(*clocksys).insertListener(listenerId, socketAddress, messageResponse);

	app.logger().information("ending Connect");

}

void ConnectionHandler::providerStartListening(Poco::Net::SocketAddress socketAddress,
										       ChoiceNet::Eco::Message & message,
										       ChoiceNet::Eco::Message & messageResponse)
{

	Poco::Util::Application& app = Poco::Util::Application::instance();
	app.logger().information("Start ProviderStartListening");

	unsigned  Uport;
	std::string port = message.getParameter("Port");
	bool v_result = Poco::NumberParser::tryParseUnsigned(port, Uport);
	std::string type = message.getParameter("Type");
	if ( Uport <= 0xFFFF)
	{
		ClockServer &server = dynamic_cast<ClockServer&>(app);
		ClockSys * clocksys = server.getClockSubsystem();
		Poco::UInt16 u16Port = (Poco::UInt16) Uport;
		(*clocksys).startListening(socketAddress, u16Port, type, messageResponse);
	}
	else
	{
		std::cout << "Invalid Port" << std::endl;
		app.logger().debug("Invalid Port");
		throw ClockServerException("Invalid Port", 301);
	}

	app.logger().information("Ending ProviderStartListening");
}

void ConnectionHandler::sendCurrentPeriod(Poco::Net::SocketAddress socketAddress,
										  ChoiceNet::Eco::Message & messageRequest,
										  ChoiceNet::Eco::Message & messageResponse)
{

	Poco::Util::Application& app = Poco::Util::Application::instance();
	app.logger().information("start sendCurrentPeriod");

	ClockServer &server = dynamic_cast<ClockServer&>(app);
	ClockSys * clocksys = server.getClockSubsystem();
	(*clocksys).sendCurrentPeriod(socketAddress, messageResponse);

	app.logger().information("ending sendCurrentPeriod");

}

void ConnectionHandler::disconnectListener(Poco::Net::SocketAddress socketAddress,
										   ChoiceNet::Eco::Message & messageRequest,
										   ChoiceNet::Eco::Message & messageResponse)
{

	Poco::Util::Application& app = Poco::Util::Application::instance();
	app.logger().information("Start disconnectListener");

	ClockServer &server = dynamic_cast<ClockServer&>(app);
	ClockSys * clocksys = server.getClockSubsystem();
	(*clocksys).deleteListener( socketAddress, messageResponse );

	app.logger().information("Ending disconnectListener");

}

void ConnectionHandler::getServices(Poco::Net::SocketAddress ipAddress,
								    ChoiceNet::Eco::Message & messageRequest,
								    ChoiceNet::Eco::Message & messageResponse)
{

	Poco::Util::Application& app = Poco::Util::Application::instance();
	app.logger().information("start getServices");

	ClockServer &server = dynamic_cast<ClockServer&>(app);
	ClockSys *sys = server.getClockSubsystem();

	if (messageRequest.existsParameter("Service")){
		std::string serviceId = messageRequest.getParameter("Service");
		(*sys).getServices(serviceId, messageResponse);
	}
	else{
		(*sys).getServices(messageResponse);
	}

	app.logger().information("Ending main getServices");
}

void ConnectionHandler::errorProcedure(ChoiceNet::Eco::Message & messageResponse)
{
	messageResponse.setParameter("Status_Code", "300");
	messageResponse.setParameter("Status_Description", "Invalid Method");
}

void ConnectionHandler::doProcessing(Poco::Net::SocketAddress socketAddress,
									 ChoiceNet::Eco::Message & message)
{

	Method meth = message.getMethod();

	Poco::Util::Application& app = Poco::Util::Application::instance();
	app.logger().information("start doProcessing");

	// This object will be the response for the calling application.
	ChoiceNet::Eco::Message messageResponse;
	messageResponse.setMethod(meth);
	try{
		switch (meth)
		{
		   case connect:
			  {
	 			// Verify the required paramters option provider
	 			// std::cout << "In Connect" << std::endl;
				Connect( socketAddress, message, messageResponse );
				break;
			  }
		   case send_port:
			  {
				// Verify the required paramters option port
				// std::cout << "In send_port" << std::endl;
				providerStartListening( socketAddress, message, messageResponse );
				break;
			  }
		   case get_current_period:
			  {
				// Verify the required paramters option port
				// std::cout << "In get_current_period" << std::endl;
				sendCurrentPeriod( socketAddress, message, messageResponse );
				break;
			  }
		   case disconnect:
			  {
				// Verify the required paramters option DISCONNECT
				// std::cout << "In disconnect" << std::endl;
				disconnectListener(socketAddress, message, messageResponse);
				break;
			  }
		   case get_services:
			  {
				// std::cout << "In Get Services" << std::endl;
				getServices(socketAddress, message, messageResponse);
				break;
		      }
			default:
			  {
				// std::cout << "Invalid method" << std::endl;
				errorProcedure(messageResponse);
				break;
			  }
		}
	}
	catch(FoundationException &e)
	{
		app.logger().information("Raise a foundation exception");
		std::string codeStr;
		Poco::NumberFormatter::append(codeStr,e.code());
		messageResponse.setParameter("Status_Code", codeStr);
		messageResponse.setParameter("Status_Description", e.message());
	}
	catch(ClockServerException &e)
	{
		// Some required parameter was not given
		app.logger().information("Raise a clockserver exception");
		std::string codeStr;
		Poco::NumberFormatter::append(codeStr,e.code());
		messageResponse.setParameter("Status_Code", codeStr);
		messageResponse.setParameter("Status_Description", e.message());
	}
	catch(...)
	{
		// Some required parameter was not given
		app.logger().information("Raise a unidentified exception");
		messageResponse.setParameter("Status_Code", "1000");
		messageResponse.setParameter("Status_Description", "Error Unidentified exception");
	}

	// send the response for the calling agent.
	std::string responseStr = messageResponse.to_string();
	size_t charactersWritten = 0;
	if ((responseStr.length() + 1) > (_fifoOut.size() + _fifoOut.used()))
	{
	   _fifoOut.resize(_fifoOut.used() + responseStr.length() + 1, true);
	}
    charactersWritten = _fifoOut.write(responseStr.c_str(), responseStr.length());

    LogStream lstr(app.logger());
	lstr << "ending doProcessing - bytes written" << charactersWritten << std::endl;

}

void ConnectionHandler::onSocketReadable(const Poco::AutoPtr<Poco::Net::ReadableNotification>& pNf)
{
	// some socket implementations (windows) report available
	// bytes on client disconnect, so we double-check here

	Poco::Util::Application& app = Poco::Util::Application::instance();

	try
	{
		if (_socket.available())
		{

			int len = _socket.receiveBytes(_fifoIn.next(), _fifoIn.available() );

			_fifoIn.advance(len);

			ClockServer &server = dynamic_cast<ClockServer&>(app);
			ClockSys *sys = server.getClockSubsystem();
			ChoiceNet::Eco::Message message;

			if ((*sys).isAlreadyListener(_socket.peerAddress()))
			{
				(*sys).addStagedData(_socket.peerAddress(), _fifoIn, len);
				bool defined = true;
				do {
					Message message;
					defined = (*sys).getMessage(_socket.peerAddress(), message);
					if (defined == true){
						app.logger().debug("message to process:%s", message.to_string());
						doProcessing(_socket.peerAddress(), message);
					}
				} while (defined == true);
			}
			else
			{
				Message message;
				app.logger().debug("new listener:%s", (_socket.peerAddress()).toString().c_str());
				std::string received;
				(*sys).getMessage(_fifoIn, len, message);
				doProcessing(_socket.peerAddress(), message);
			}
		}
		else
		{
			delete this;
			// std::cout << "Socket is unavailable" << std::endl;
		}
	}
	catch(ClockServerException &e)
	{
		// Some required parameter was not given
		app.logger().debug(Poco::format("Raise a clockserver exception - %s, %d ", e.message(), e.code()) );
	}

}

void ConnectionHandler::onSocketWritable(const Poco::AutoPtr<Poco::Net::WritableNotification>& pNf)
{

	int len = _socket.sendBytes((_fifoOut.buffer()).begin(), _fifoOut.used());
	_fifoOut.drain(len);
}

void ConnectionHandler::onSocketShutdown(const Poco::AutoPtr<Poco::Net::ShutdownNotification>& pNf)
{
	Poco::Util::Application& app = Poco::Util::Application::instance();
	app.logger().debug("Socket shutdown");
	std::cout << "Socket Error occurs" << std::endl;
	delete this;
}

void ConnectionHandler::onSocketError(const Poco::AutoPtr<Poco::Net::ErrorNotification>& pNf)
{
	Poco::Util::Application& app = Poco::Util::Application::instance();
	app.logger().debug("Socket Error occurs");
	std::cout << "Socket Error occurs" << std::endl;
}

void ConnectionHandler::onSocketIdle(const Poco::AutoPtr<Poco::Net::IdleNotification>& pNf)
{
	Poco::Util::Application& app = Poco::Util::Application::instance();
	app.logger().debug("On idle notification");
	std::cout << "On idle notification" << std::endl;
	sleep(0.00001);
}

}   /// End Eco namespace

}  /// End ChoiceNet namespace

